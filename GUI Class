#pragma once
#include<string>
#include<list>
#include<unordered_map>
#include <queue>
#include <vector>
#include <stack>
#include <functional> //for greater, for sorting pq ascending
#define INF  INT_MAX



using namespace std;
class graph
{
	unordered_map <int, pair<int, pair<int, int>>> edgesInd;
	unordered_map<string, int>indicies;
public:
	int numEdges;
	stack<string> backTrack;
	graph();
	unordered_map<string, list<pair<string, int>>> adjList;

	void addVertex(string ver)
	{
		if (adjList.find(ver) == adjList.end())
			adjList[ver];
	}
	void addEdge(string src, string dest, int weight)
	{
		//if edge already exists,update weight 
		if (numEdges > 0 && areAdjacent(src, dest))
		{
			updateWeight(src, dest, weight);
			return;
		}
		adjList[src].push_back(make_pair(dest, weight));
		//check if destination is found
		addVertex(dest);
		numEdges++;
	}
	void updateWeight(string src, string dest, int weight)
	{
		bool found = false;
		for (auto move = adjList.find(src)->second.begin(); move != adjList.find(src)->second.end(); ++move)
		{
			if (move->first == dest)
			{
				move->second = weight;
				found = true;
				return;
			}
		}
	}
	bool areAdjacent(string src, string dest)
	{
		for (auto it2 = adjList.find(src)->second.begin(); it2 != adjList.find(src)->second.end(); it2++)
		if (it2->first == dest)
			return true;
		return false;
	}
	void deleteVertex(string vertex)
	{
		//vertex not found
		if (adjList.find(vertex) == adjList.end())
			return;
		//deleting vertex as destination
		for (auto it = adjList.begin(); it != adjList.end(); ++it)
		{
			for (auto o = it->second.begin(); o != it->second.end(); ++o)
			{
				if (o->first == vertex)
				{
					//adjlist[it->first].remove(*o);
					adjList[it->first].erase(o);
					int x = it->second.size();
					break; //to avoid dereferincing an iterator to a non existing list
				}
			}
			//deleting vertex as source
			if (it->first == vertex)
			{
				adjList.find(vertex)->second.clear();
				adjList.erase(vertex);
			}
		}
	}
	void deleteEdge(string src, string dest)
	{
		if (adjList.find(src) == adjList.end())
			return;
		for (auto del = adjList.find(src)->second.begin(); del != adjList.find(src)->second.end(); ++del)
		if (del->first == dest)
		{
			adjList[src].remove(*del);
			numEdges--;
			//adjlist[source].erase(del);
			return;
		}
	}
	void getIndex()
	{
		int i = 0, j = 0;
		list<pair<string, int>>::iterator o;
		for (auto it = adjList.begin(); it != adjList.end(); ++it)
		{
			indicies[it->first] = i;
			++i;
		}
		for (auto it = adjList.begin(); it != adjList.end(); ++it)
		{
			for (o = it->second.begin(); o != it->second.end(); ++o)
			{
				edgesInd[j] = make_pair(indicies[it->first], make_pair(indicies[o->first], o->second));
				++j;
			}

		}
	}
	int Bellman(string src, string des)
	{
		getIndex();
		vector<pair<int, string>> distance(numVertices());
		string city = des;
		int c = 0;
		for (int i = 0; i < numVertices(); ++i)
		{
			distance[i].first = INF;
		}
		distance[indicies[src]].first = 0;
		for (int i = 0; i < numVertices() - 1; ++i)
		{
			c = 0;
			for (int j = 0; j < numEdges; ++j)
			{
				int s = edgesInd[j].first;
				int d = edgesInd[j].second.first;
				int w = edgesInd[j].second.second;
				if (distance[s].first != INF && distance[s].first + w < distance[d].first)
				{
					distance[d].first = distance[s].first + w;
					for (auto it = indicies.begin(); it != indicies.end(); ++it)
					{
						if (it->second == s)
							distance[d].second = it->first;
					}
					c++;
				}
			}
			if (c == 0)
			{
				break;
			}
		}
		backTrack.push(des);
		while (city != src)
		{
			backTrack.push(distance[indicies[city]].second);
			city = distance[indicies[city]].second;
		}
		return distance[indicies[des]].first;
	}
	int numVertices()
	{
		return(adjList.size());
	}
	void deleteGraph()
	{
		adjList.clear();
	}
	~graph()
	{
		deleteGraph();
	}
};

