//floyd.h
class Index{
	public:
		int label;
		string cityName;
	}index;
	vector<Index>v;
	void getIndex();

//floyd.cpp
void Graph::getIndex()
{
	int i = 0;

	for (auto it = adjList.begin(); it != adjList.end(); ++it)
	{
		index.cityName = it->first;
		index.label = i;
		v.push_back(index);
		i++;
	}
}
vector<vector<int>> Graph::floyd(){
	
	vector<vector<int>>floydMatrix(numVertices(), vector<int>(numVertices()));
	getIndex();
	
	int geti=0, getj=0 , c=0;
	//initializing the first matrix
	for (auto it = adjList.begin(); it != adjList.end(); ++it)
	{
		for (int i = 0; i < v.size(); ++i)
		{
			 if (v[i].cityName == it->first)
			 {
				geti = v[i].label;
			 }
			 else if (i != c && floydMatrix[c][i] == 0)
				 floydMatrix[c][i] = INF;
				
		}
		for (auto s = it->second.begin(); s != it->second.end(); ++s)
		{
			for (int i = 0; i < v.size(); ++i)
			{
				if (v[i].cityName == s->first)
				{
					getj = v[i].label;
					floydMatrix[geti][getj] = s->second;
					break;
				}
			}
	    }
		c++;
	}
	
	//getting the shortest path between any node
	for (int k = 0; k < numVertices(); ++k)
	{
		for (int i = 0; i < numVertices(); ++i)
		{
			for (int j = 0; j < numVertices(); ++j)
			{
				if (i == j || i == k || j == k)
					continue;
				if (floydMatrix[i][k] + floydMatrix[k][j] < floydMatrix[i][j] && (floydMatrix[i][k] != INF && floydMatrix[k][j]!=INF))
					floydMatrix[i][j] = floydMatrix[i][k] + floydMatrix[k][j];
			}
		}
	}
	return floydMatrix;
}
